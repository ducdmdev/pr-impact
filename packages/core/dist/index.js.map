{"version":3,"sources":["../src/analyzer.ts","../src/diff/diff-parser.ts","../src/diff/file-categorizer.ts","../src/breaking/detector.ts","../src/breaking/export-differ.ts","../src/breaking/signature-differ.ts","../src/coverage/test-mapper.ts","../src/coverage/coverage-checker.ts","../src/docs/staleness-checker.ts","../src/impact/impact-graph.ts","../src/risk/factors.ts","../src/risk/risk-calculator.ts","../src/output/markdown-reporter.ts","../src/output/json-reporter.ts"],"sourcesContent":["import simpleGit from 'simple-git';\nimport { PRAnalysis, AnalysisOptions, ChangedFile, BreakingChange, TestCoverageReport, DocStalenessReport, ImpactGraph, RiskAssessment } from './types.js';\nimport { parseDiff } from './diff/diff-parser.js';\nimport { detectBreakingChanges } from './breaking/detector.js';\nimport { checkTestCoverage } from './coverage/coverage-checker.js';\nimport { checkDocStaleness } from './docs/staleness-checker.js';\nimport { buildImpactGraph } from './impact/impact-graph.js';\nimport { calculateRisk } from './risk/risk-calculator.js';\n\n/**\n * Resolve the default base branch for the repository by checking whether\n * 'main' or 'master' exists in the local branch list.\n */\nasync function resolveDefaultBaseBranch(repoPath: string): Promise<string> {\n  const git = simpleGit(repoPath);\n  const branchSummary = await git.branch();\n\n  if (branchSummary.all.includes('main')) {\n    return 'main';\n  }\n\n  if (branchSummary.all.includes('master')) {\n    return 'master';\n  }\n\n  // If neither 'main' nor 'master' is found, fall back to 'main' and let\n  // the caller deal with any resulting git error.\n  return 'main';\n}\n\n/**\n * Build a human-readable summary of the PR analysis results.\n */\nfunction generateSummary(\n  changedFiles: ChangedFile[],\n  breakingChanges: BreakingChange[],\n  testCoverage: TestCoverageReport,\n  riskScore: RiskAssessment,\n): string {\n  const totalAdditions = changedFiles.reduce((sum, f) => sum + f.additions, 0);\n  const totalDeletions = changedFiles.reduce((sum, f) => sum + f.deletions, 0);\n\n  const parts: string[] = [];\n\n  parts.push(\n    `This PR changes ${changedFiles.length} file${changedFiles.length === 1 ? '' : 's'} ` +\n    `(+${totalAdditions}/-${totalDeletions}) with a ${riskScore.level} risk score of ${riskScore.score}/100.`,\n  );\n\n  if (breakingChanges.length > 0) {\n    parts.push(\n      `Found ${breakingChanges.length} breaking change${breakingChanges.length === 1 ? '' : 's'} affecting exported APIs.`,\n    );\n  }\n\n  if (testCoverage.gaps.length > 0) {\n    parts.push(\n      `${testCoverage.gaps.length} source file${testCoverage.gaps.length === 1 ? '' : 's'} lack${testCoverage.gaps.length === 1 ? 's' : ''} corresponding test changes.`,\n    );\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Run all analysis steps on a pull request and produce a comprehensive report.\n *\n * Steps:\n *   1. Resolve base and head branches\n *   2. Verify the repository and branches\n *   3. Parse the diff to get changed files\n *   4. Run breaking-change detection, test-coverage checking, doc-staleness\n *      checking, and impact-graph building in parallel\n *   5. Calculate the overall risk score\n *   6. Generate a human-readable summary\n */\nexport async function analyzePR(options: AnalysisOptions): Promise<PRAnalysis> {\n  const { repoPath, skipBreaking, skipCoverage, skipDocs } = options;\n\n  // --- 1. Resolve branches --------------------------------------------------\n  const baseBranch = options.baseBranch ?? await resolveDefaultBaseBranch(repoPath);\n  const headBranch = options.headBranch ?? 'HEAD';\n\n  // --- 2. Verify the repo exists and branches are valid ---------------------\n  const git = simpleGit(repoPath);\n\n  // This will throw if the path is not a git repository.\n  await git.checkIsRepo();\n\n  // Verify that the base branch ref is valid.\n  await git.revparse([baseBranch]);\n\n  // Verify that the head branch ref is valid.\n  await git.revparse([headBranch]);\n\n  // --- 3. Parse the diff ----------------------------------------------------\n  const changedFiles = await parseDiff(repoPath, baseBranch, headBranch);\n\n  // --- 4. Run parallel analysis steps ---------------------------------------\n  const [breakingChanges, testCoverage, docStaleness, impactGraph] =\n    await Promise.all([\n      // Breaking change detection\n      skipBreaking\n        ? Promise.resolve<BreakingChange[]>([])\n        : detectBreakingChanges(repoPath, baseBranch, headBranch, changedFiles),\n\n      // Test coverage analysis\n      skipCoverage\n        ? Promise.resolve<TestCoverageReport>({\n            changedSourceFiles: 0,\n            sourceFilesWithTestChanges: 0,\n            coverageRatio: 0,\n            gaps: [],\n          })\n        : checkTestCoverage(repoPath, changedFiles),\n\n      // Documentation staleness checking\n      skipDocs\n        ? Promise.resolve<DocStalenessReport>({\n            staleReferences: [],\n            checkedFiles: [],\n          })\n        : checkDocStaleness(repoPath, changedFiles, baseBranch, headBranch),\n\n      // Impact graph building\n      buildImpactGraph(repoPath, changedFiles),\n    ]);\n\n  // --- 5. Calculate risk score ----------------------------------------------\n  const riskScore = calculateRisk(\n    changedFiles,\n    breakingChanges,\n    testCoverage,\n    docStaleness,\n    impactGraph,\n  );\n\n  // --- 6. Generate summary --------------------------------------------------\n  const summary = generateSummary(\n    changedFiles,\n    breakingChanges,\n    testCoverage,\n    riskScore,\n  );\n\n  // --- 7. Assemble and return the full analysis -----------------------------\n  return {\n    repoPath,\n    baseBranch,\n    headBranch,\n    changedFiles,\n    breakingChanges,\n    testCoverage,\n    docStaleness,\n    impactGraph,\n    riskScore,\n    summary,\n  };\n}\n","import simpleGit from 'simple-git';\nimport { ChangedFile } from '../types.js';\nimport { categorizeFile } from './file-categorizer.js';\n\nconst EXTENSION_LANGUAGE_MAP: Record<string, string> = {\n  '.ts': 'typescript',\n  '.tsx': 'typescript',\n  '.js': 'javascript',\n  '.jsx': 'javascript',\n  '.mjs': 'javascript',\n  '.cjs': 'javascript',\n  '.py': 'python',\n  '.go': 'go',\n  '.rs': 'rust',\n  '.java': 'java',\n  '.c': 'c',\n  '.cpp': 'cpp',\n  '.h': 'c',\n  '.hpp': 'cpp',\n  '.rb': 'ruby',\n  '.php': 'php',\n  '.swift': 'swift',\n  '.kt': 'kotlin',\n  '.scala': 'scala',\n  '.cs': 'csharp',\n  '.vue': 'vue',\n  '.svelte': 'svelte',\n  '.md': 'markdown',\n  '.mdx': 'markdown',\n  '.json': 'json',\n  '.yaml': 'yaml',\n  '.yml': 'yaml',\n  '.toml': 'toml',\n  '.xml': 'xml',\n  '.html': 'html',\n  '.css': 'css',\n  '.scss': 'scss',\n  '.less': 'less',\n  '.sql': 'sql',\n  '.sh': 'shell',\n  '.bash': 'shell',\n  '.zsh': 'shell',\n  '.dockerfile': 'dockerfile',\n  '.graphql': 'graphql',\n  '.gql': 'graphql',\n  '.proto': 'protobuf',\n  '.txt': 'text',\n  '.rst': 'restructuredtext',\n};\n\nfunction detectLanguage(filePath: string): string {\n  const fileName = filePath.split('/').pop() ?? '';\n  const lowerName = fileName.toLowerCase();\n\n  if (lowerName === 'dockerfile') return 'dockerfile';\n  if (lowerName === 'makefile') return 'makefile';\n\n  const lastDot = filePath.lastIndexOf('.');\n  if (lastDot === -1) return 'unknown';\n\n  const ext = filePath.slice(lastDot).toLowerCase();\n  return EXTENSION_LANGUAGE_MAP[ext] ?? 'unknown';\n}\n\n/**\n * Resolves a file path from a diff entry, handling renames.\n * simple-git may report renames as \"old => new\" or \"{prefix/old => prefix/new}/suffix\".\n * Returns { newPath, oldPath } where oldPath is set only for renames.\n */\nfunction resolveFilePath(raw: string): { newPath: string; oldPath?: string } {\n  // Handle brace-style renames: \"dir/{old.ts => new.ts}\" or \"{old => new}/file.ts\"\n  const braceMatch = raw.match(/^(.*?)\\{(.+?) => (.+?)\\}(.*)$/);\n  if (braceMatch) {\n    const [, prefix, oldPart, newPart, suffix] = braceMatch;\n    const oldPath = `${prefix}${oldPart}${suffix}`.replace(/\\/\\//g, '/');\n    const newPath = `${prefix}${newPart}${suffix}`.replace(/\\/\\//g, '/');\n    return { newPath, oldPath };\n  }\n\n  // Handle simple renames: \"old.ts => new.ts\"\n  const simpleMatch = raw.match(/^(.+?) => (.+?)$/);\n  if (simpleMatch) {\n    return { newPath: simpleMatch[2], oldPath: simpleMatch[1] };\n  }\n\n  return { newPath: raw };\n}\n\nfunction determineStatus(\n  filePath: string,\n  created: string[],\n  deleted: string[],\n  renamed: string[],\n): ChangedFile['status'] {\n  if (created.includes(filePath)) return 'added';\n  if (deleted.includes(filePath)) return 'deleted';\n  if (renamed.includes(filePath)) return 'renamed';\n  return 'modified';\n}\n\nexport async function parseDiff(\n  repoPath: string,\n  base: string,\n  head: string,\n): Promise<ChangedFile[]> {\n  const git = simpleGit(repoPath);\n  const diffSummary = await git.diffSummary([`${base}..${head}`]);\n\n  // Build lookup sets from the categorized arrays in the diff summary.\n  // simple-git provides .created, .deleted, .renamed as arrays of file paths.\n  const createdFiles: string[] = (diffSummary as any).created ?? [];\n  const deletedFiles: string[] = (diffSummary as any).deleted ?? [];\n  const renamedFiles: string[] = (diffSummary as any).renamed ?? [];\n\n  const changedFiles: ChangedFile[] = [];\n\n  for (const file of diffSummary.files) {\n    const { newPath, oldPath } = resolveFilePath(file.file);\n\n    const status = determineStatus(\n      file.file,\n      createdFiles,\n      deletedFiles,\n      renamedFiles,\n    );\n\n    // If we detected a rename from the path pattern but simple-git didn't flag it,\n    // treat it as renamed when oldPath is present.\n    const finalStatus: ChangedFile['status'] =\n      status === 'modified' && oldPath ? 'renamed' : status;\n\n    const changedFile: ChangedFile = {\n      path: newPath,\n      status: finalStatus,\n      additions: 'insertions' in file ? file.insertions : 0,\n      deletions: 'deletions' in file ? file.deletions : 0,\n      language: detectLanguage(newPath),\n      category: categorizeFile(newPath),\n    };\n\n    if (oldPath) {\n      changedFile.oldPath = oldPath;\n    }\n\n    changedFiles.push(changedFile);\n  }\n\n  return changedFiles;\n}\n","import { ChangedFile } from '../types.js';\n\nconst SOURCE_EXTENSIONS = new Set([\n  '.ts', '.tsx', '.js', '.jsx',\n  '.py', '.go', '.rs', '.java',\n  '.c', '.cpp', '.h',\n  '.rb', '.php', '.swift',\n  '.kt', '.scala', '.cs',\n  '.vue', '.svelte',\n]);\n\nconst DOC_EXTENSIONS = new Set(['.md', '.mdx', '.txt', '.rst']);\n\nconst CONFIG_FILENAMES = new Set([\n  'package.json',\n  'tsconfig.json',\n  'turbo.json',\n  'dockerfile',\n  'makefile',\n  '.gitignore',\n  '.npmrc',\n  'pnpm-workspace.yaml',\n  'pnpm-lock.yaml',\n  'yarn.lock',\n  'package-lock.json',\n]);\n\nconst CONFIG_PREFIXES = [\n  '.eslintrc',\n  '.prettierrc',\n  'webpack.config.',\n  'vite.config.',\n  'jest.config.',\n  'vitest.config.',\n  'docker-compose.',\n  '.env',\n];\n\nfunction isTestFile(filePath: string): boolean {\n  const normalized = filePath.replace(/\\\\/g, '/');\n  const fileName = normalized.split('/').pop() ?? '';\n\n  return (\n    normalized.includes('__tests__/') ||\n    normalized.includes('__tests__\\\\') ||\n    normalized.includes('/test/') ||\n    normalized.includes('/tests/') ||\n    fileName.includes('.test.') ||\n    fileName.includes('.spec.') ||\n    fileName.startsWith('test')\n  );\n}\n\nfunction isDocFile(filePath: string): boolean {\n  const normalized = filePath.replace(/\\\\/g, '/');\n  const ext = getExtension(filePath);\n\n  return (\n    DOC_EXTENSIONS.has(ext) ||\n    normalized.startsWith('docs/') ||\n    normalized.startsWith('doc/')\n  );\n}\n\nfunction isConfigFile(filePath: string): boolean {\n  const normalized = filePath.replace(/\\\\/g, '/');\n  const fileName = (normalized.split('/').pop() ?? '').toLowerCase();\n\n  if (normalized.startsWith('.github/')) {\n    return true;\n  }\n\n  if (CONFIG_FILENAMES.has(fileName)) {\n    return true;\n  }\n\n  for (const prefix of CONFIG_PREFIXES) {\n    if (fileName.startsWith(prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isSourceFile(filePath: string): boolean {\n  const ext = getExtension(filePath);\n  return SOURCE_EXTENSIONS.has(ext);\n}\n\nfunction getExtension(filePath: string): string {\n  const lastDot = filePath.lastIndexOf('.');\n  if (lastDot === -1) return '';\n  return filePath.slice(lastDot).toLowerCase();\n}\n\nexport function categorizeFile(filePath: string): ChangedFile['category'] {\n  if (isTestFile(filePath)) return 'test';\n  if (isDocFile(filePath)) return 'doc';\n  if (isConfigFile(filePath)) return 'config';\n  if (isSourceFile(filePath)) return 'source';\n  return 'other';\n}\n","import simpleGit from 'simple-git';\nimport { BreakingChange, ChangedFile } from '../types.js';\nimport { diffExports, parseExports } from './export-differ.js';\nimport { diffSignatures } from './signature-differ.js';\n\n/** File extensions that we analyze for breaking changes. */\nconst ANALYZABLE_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx']);\n\n/**\n * Get the file extension (lowercased) from a file path.\n */\nfunction getExtension(filePath: string): string {\n  const lastDot = filePath.lastIndexOf('.');\n  if (lastDot === -1) return '';\n  return filePath.slice(lastDot).toLowerCase();\n}\n\n/**\n * Safely retrieve file content at a specific git ref.\n * Returns `null` if the file doesn't exist at that ref.\n */\nasync function getFileAtRef(\n  git: ReturnType<typeof simpleGit>,\n  ref: string,\n  filePath: string,\n): Promise<string | null> {\n  try {\n    return await git.show([`${ref}:${filePath}`]);\n  } catch {\n    // File doesn't exist at this ref (new file, or path changed)\n    return null;\n  }\n}\n\n/**\n * Detect breaking changes between two branches by analyzing export differences\n * in changed source files.\n *\n * @param repoPath     - Absolute path to the git repository\n * @param baseBranch   - The base branch/ref (e.g. \"main\", \"origin/main\")\n * @param headBranch   - The head branch/ref (e.g. \"feature/xyz\", \"HEAD\")\n * @param changedFiles - List of files changed between the two branches\n * @returns Array of detected breaking changes\n */\nexport async function detectBreakingChanges(\n  repoPath: string,\n  baseBranch: string,\n  headBranch: string,\n  changedFiles: ChangedFile[],\n): Promise<BreakingChange[]> {\n  const git = simpleGit(repoPath);\n  const breakingChanges: BreakingChange[] = [];\n\n  // Only analyze source files that were modified or deleted\n  const filesToAnalyze = changedFiles.filter((f) => {\n    const ext = getExtension(f.path);\n    return (\n      ANALYZABLE_EXTENSIONS.has(ext) &&\n      (f.status === 'modified' || f.status === 'deleted')\n    );\n  });\n\n  for (const file of filesToAnalyze) {\n    try {\n      const baseContent = await getFileAtRef(git, baseBranch, file.path);\n\n      // If we can't get the base content, we can't detect breaking changes\n      if (baseContent === null) {\n        continue;\n      }\n\n      if (file.status === 'deleted') {\n        // Every export in a deleted file is a breaking change\n        const baseExports = parseExports(baseContent, file.path);\n\n        for (const sym of baseExports.symbols) {\n          breakingChanges.push({\n            filePath: file.path,\n            type: 'removed_export',\n            symbolName: sym.name,\n            before: formatSymbolDescription(sym),\n            after: null,\n            severity: 'high',\n            consumers: [],\n          });\n        }\n      } else {\n        // File was modified — compare exports\n        const headContent = await getFileAtRef(git, headBranch, file.path);\n\n        if (headContent === null) {\n          // Shouldn't happen for a 'modified' file, but handle gracefully\n          continue;\n        }\n\n        const diff = diffExports(file.path, baseContent, headContent);\n\n        // Removed exports → high severity\n        for (const sym of diff.removed) {\n          breakingChanges.push({\n            filePath: file.path,\n            type: 'removed_export',\n            symbolName: sym.name,\n            before: formatSymbolDescription(sym),\n            after: null,\n            severity: 'high',\n            consumers: [],\n          });\n        }\n\n        // Modified signatures → medium severity\n        for (const { before, after } of diff.modified) {\n          const sigDiff = diffSignatures(before.signature, after.signature);\n\n          // Only report if there's an actual signature change\n          // (kind changes are also caught here since diffExports flags them)\n          if (sigDiff.changed || before.kind !== after.kind) {\n            breakingChanges.push({\n              filePath: file.path,\n              type: before.kind !== after.kind ? 'changed_type' : 'changed_signature',\n              symbolName: before.name,\n              before: formatSymbolDescription(before),\n              after: formatSymbolDescription(after),\n              severity: 'medium',\n              consumers: [],\n            });\n          }\n        }\n      }\n    } catch (error) {\n      // If we can't analyze a file (e.g. binary, encoding issues), skip it.\n      // In a production tool we'd log this; for now we silently continue.\n      continue;\n    }\n  }\n\n  return breakingChanges;\n}\n\n/**\n * Format a symbol into a human-readable description string.\n */\nfunction formatSymbolDescription(sym: {\n  name: string;\n  kind: string;\n  signature?: string;\n  isDefault: boolean;\n}): string {\n  const parts: string[] = [];\n\n  if (sym.isDefault) {\n    parts.push('default');\n  }\n\n  parts.push(sym.kind);\n  parts.push(sym.name);\n\n  if (sym.signature) {\n    parts.push(sym.signature);\n  }\n\n  return parts.join(' ');\n}\n","import { ExportedSymbol, FileExports } from '../types.js';\n\n/**\n * Regex patterns for extracting exported symbols from TypeScript/JavaScript.\n *\n * Each pattern captures:\n *  - The symbol name\n *  - Optionally the kind (function, class, etc.)\n *  - Optionally the signature (parameter list + return type for functions)\n */\n\n// export async? function NAME(...)\nconst EXPORT_FUNCTION_RE =\n  /export\\s+(?:async\\s+)?function\\s+(\\w+)\\s*(\\([^)]*\\)(?:\\s*:\\s*[^{;]+)?)/g;\n\n// export default async? function NAME(...)\nconst EXPORT_DEFAULT_FUNCTION_RE =\n  /export\\s+default\\s+(?:async\\s+)?function\\s+(\\w+)\\s*(\\([^)]*\\)(?:\\s*:\\s*[^{;]+)?)/g;\n\n// export default async? function(...)  — unnamed default\nconst EXPORT_DEFAULT_ANON_FUNCTION_RE =\n  /export\\s+default\\s+(?:async\\s+)?function\\s*(\\([^)]*\\)(?:\\s*:\\s*[^{;]+)?)/g;\n\n// export class NAME\nconst EXPORT_CLASS_RE = /export\\s+class\\s+(\\w+)/g;\n\n// export default class NAME\nconst EXPORT_DEFAULT_CLASS_RE = /export\\s+default\\s+class\\s+(\\w+)/g;\n\n// export const NAME / export let NAME / export var NAME\n// Also handles: export const NAME: Type = ...\nconst EXPORT_VARIABLE_RE =\n  /export\\s+(const|let|var)\\s+(\\w+)\\s*(?::\\s*([^=;]+?))?(?:\\s*=|;)/g;\n\n// export interface NAME\nconst EXPORT_INTERFACE_RE = /export\\s+interface\\s+(\\w+)/g;\n\n// export type NAME\nconst EXPORT_TYPE_RE = /export\\s+type\\s+(\\w+)/g;\n\n// export enum NAME\nconst EXPORT_ENUM_RE = /export\\s+enum\\s+(\\w+)/g;\n\n// export { a, b, c } or export { a as b, c as default }\nconst EXPORT_NAMED_RE = /export\\s*\\{([^}]+)\\}/g;\n\n// export default <expression> (catch-all for default exports not matched above)\nconst EXPORT_DEFAULT_EXPR_RE = /export\\s+default\\s+(?!function|class|interface|type|enum)(\\w+)/g;\n\n/**\n * Strip single-line and multi-line comments from source code to avoid\n * matching exports inside comments.\n */\nfunction stripComments(content: string): string {\n  // Remove single-line comments but preserve strings\n  // Remove block comments\n  return content\n    .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n    .replace(/\\/\\/.*$/gm, '');\n}\n\n/**\n * Normalize a signature string by collapsing whitespace.\n */\nfunction normalizeSignature(sig: string): string {\n  return sig.replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Parse a TypeScript/JavaScript file's content to extract all exported symbols.\n */\nexport function parseExports(content: string, filePath: string): FileExports {\n  const symbols: ExportedSymbol[] = [];\n  const seen = new Set<string>();\n\n  const stripped = stripComments(content);\n\n  function addSymbol(sym: ExportedSymbol): void {\n    // Use a compound key to differentiate default vs named\n    const key = sym.isDefault ? `default::${sym.name}` : sym.name;\n    if (!seen.has(key)) {\n      seen.add(key);\n      symbols.push(sym);\n    }\n  }\n\n  // 1. export default function NAME(...)\n  {\n    const re = new RegExp(EXPORT_DEFAULT_FUNCTION_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      addSymbol({\n        name: m[1],\n        kind: 'function',\n        signature: normalizeSignature(m[2]),\n        isDefault: true,\n      });\n    }\n  }\n\n  // 2. export default anonymous function(...)\n  {\n    const re = new RegExp(EXPORT_DEFAULT_ANON_FUNCTION_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      // Only match if this is truly anonymous (no name captured by the named variant)\n      // The named variant regex already matched named ones, so check if the char before '(' is not a word char\n      const beforeParen = stripped.substring(0, m.index + m[0].indexOf('('));\n      if (/function\\s*$/.test(beforeParen)) {\n        addSymbol({\n          name: 'default',\n          kind: 'function',\n          signature: normalizeSignature(m[1]),\n          isDefault: true,\n        });\n      }\n    }\n  }\n\n  // 3. export function NAME(...)\n  {\n    const re = new RegExp(EXPORT_FUNCTION_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      // Ensure this is not a \"default\" export (already handled above)\n      const prefix = stripped.substring(Math.max(0, m.index - 10), m.index + 7);\n      if (prefix.includes('default')) continue;\n\n      addSymbol({\n        name: m[1],\n        kind: 'function',\n        signature: normalizeSignature(m[2]),\n        isDefault: false,\n      });\n    }\n  }\n\n  // 4. export default class NAME\n  {\n    const re = new RegExp(EXPORT_DEFAULT_CLASS_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      addSymbol({\n        name: m[1],\n        kind: 'class',\n        isDefault: true,\n      });\n    }\n  }\n\n  // 5. export class NAME\n  {\n    const re = new RegExp(EXPORT_CLASS_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      const prefix = stripped.substring(Math.max(0, m.index - 10), m.index + 7);\n      if (prefix.includes('default')) continue;\n\n      addSymbol({\n        name: m[1],\n        kind: 'class',\n        isDefault: false,\n      });\n    }\n  }\n\n  // 6. export const/let/var NAME\n  {\n    const re = new RegExp(EXPORT_VARIABLE_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      const varKeyword = m[1]; // const, let, var\n      const name = m[2];\n      const typeAnnotation = m[3] ? normalizeSignature(m[3]) : undefined;\n\n      addSymbol({\n        name,\n        kind: varKeyword === 'const' ? 'const' : 'variable',\n        signature: typeAnnotation,\n        isDefault: false,\n      });\n    }\n  }\n\n  // 7. export interface NAME\n  {\n    const re = new RegExp(EXPORT_INTERFACE_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      addSymbol({\n        name: m[1],\n        kind: 'interface',\n        isDefault: false,\n      });\n    }\n  }\n\n  // 8. export type NAME (but not \"export type {\" which is a re-export)\n  {\n    const re = new RegExp(EXPORT_TYPE_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      // Skip \"export type {\" — that's a type-only re-export block, not a type alias\n      const afterMatch = stripped.substring(m.index + m[0].length).trimStart();\n      if (afterMatch.startsWith('{')) continue;\n\n      addSymbol({\n        name: m[1],\n        kind: 'type',\n        isDefault: false,\n      });\n    }\n  }\n\n  // 9. export enum NAME\n  {\n    const re = new RegExp(EXPORT_ENUM_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      addSymbol({\n        name: m[1],\n        kind: 'enum',\n        isDefault: false,\n      });\n    }\n  }\n\n  // 10. export { a, b, c } and export { a as b }\n  {\n    const re = new RegExp(EXPORT_NAMED_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      // Check if this is preceded by \"type\" → export type { ... }\n      const preceding = stripped.substring(Math.max(0, m.index - 6), m.index);\n      const isTypeOnly = /type\\s*$/.test(preceding);\n\n      const inner = m[1];\n      const items = inner.split(',');\n\n      for (const item of items) {\n        const trimmed = item.trim();\n        if (!trimmed) continue;\n\n        // Handle \"name as alias\" patterns\n        const asMatch = trimmed.match(/^(\\w+)\\s+as\\s+(\\w+)$/);\n        let exportedName: string;\n        let isDefault = false;\n\n        if (asMatch) {\n          exportedName = asMatch[2];\n          if (exportedName === 'default') {\n            isDefault = true;\n            exportedName = asMatch[1]; // Use original name for tracking\n          }\n        } else {\n          exportedName = trimmed;\n        }\n\n        // Skip if not a valid identifier\n        if (!/^\\w+$/.test(exportedName)) continue;\n\n        addSymbol({\n          name: exportedName,\n          kind: isTypeOnly ? 'type' : 'variable',\n          isDefault,\n        });\n      }\n    }\n  }\n\n  // 11. export default <expression> (identifier)\n  {\n    const re = new RegExp(EXPORT_DEFAULT_EXPR_RE.source, 'g');\n    let m: RegExpExecArray | null;\n    while ((m = re.exec(stripped)) !== null) {\n      addSymbol({\n        name: m[1],\n        kind: 'variable',\n        isDefault: true,\n      });\n    }\n  }\n\n  return { filePath, symbols };\n}\n\n/**\n * Compare exports between the base and head version of a file.\n *\n * Returns:\n *  - removed:  symbols present in base but missing from head\n *  - added:    symbols present in head but missing from base\n *  - modified: symbols present in both but whose signature changed\n */\nexport function diffExports(\n  basePath: string,\n  baseContent: string,\n  headContent: string,\n): {\n  removed: ExportedSymbol[];\n  added: ExportedSymbol[];\n  modified: Array<{ before: ExportedSymbol; after: ExportedSymbol }>;\n} {\n  const baseExports = parseExports(baseContent, basePath);\n  const headExports = parseExports(headContent, basePath);\n\n  // Build lookup maps keyed by (name + isDefault) for accurate matching\n  const baseMap = new Map<string, ExportedSymbol>();\n  for (const sym of baseExports.symbols) {\n    const key = sym.isDefault ? `default::${sym.name}` : sym.name;\n    baseMap.set(key, sym);\n  }\n\n  const headMap = new Map<string, ExportedSymbol>();\n  for (const sym of headExports.symbols) {\n    const key = sym.isDefault ? `default::${sym.name}` : sym.name;\n    headMap.set(key, sym);\n  }\n\n  const removed: ExportedSymbol[] = [];\n  const added: ExportedSymbol[] = [];\n  const modified: Array<{ before: ExportedSymbol; after: ExportedSymbol }> = [];\n\n  // Find removed and modified symbols\n  for (const [key, baseSym] of baseMap) {\n    const headSym = headMap.get(key);\n    if (!headSym) {\n      removed.push(baseSym);\n    } else {\n      // Check if signature or kind changed\n      const baseSig = baseSym.signature ?? '';\n      const headSig = headSym.signature ?? '';\n      const kindChanged = baseSym.kind !== headSym.kind;\n      const sigChanged = baseSig !== headSig;\n\n      if (kindChanged || sigChanged) {\n        modified.push({ before: baseSym, after: headSym });\n      }\n    }\n  }\n\n  // Find added symbols\n  for (const [key, headSym] of headMap) {\n    if (!baseMap.has(key)) {\n      added.push(headSym);\n    }\n  }\n\n  return { removed, added, modified };\n}\n","/**\n * Compare function/method signatures between two versions of a symbol.\n *\n * Signatures are expected in the form: `(param1: Type1, param2: Type2): ReturnType`\n * This module performs structural comparison by splitting parameters and return types.\n */\n\n/**\n * Normalize whitespace in a signature fragment for consistent comparison.\n */\nfunction normalize(s: string): string {\n  return s.replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Split a parameter list string into individual parameters, respecting\n * nested angle brackets, parentheses, and square brackets so that\n * generics like `Map<string, number>` are not split on the inner comma.\n */\nfunction splitParameters(paramStr: string): string[] {\n  const params: string[] = [];\n  let depth = 0;\n  let current = '';\n\n  for (const ch of paramStr) {\n    if (ch === '<' || ch === '(' || ch === '[' || ch === '{') {\n      depth++;\n      current += ch;\n    } else if (ch === '>' || ch === ')' || ch === ']' || ch === '}') {\n      depth--;\n      current += ch;\n    } else if (ch === ',' && depth === 0) {\n      const trimmed = current.trim();\n      if (trimmed) params.push(trimmed);\n      current = '';\n    } else {\n      current += ch;\n    }\n  }\n\n  const trimmed = current.trim();\n  if (trimmed) params.push(trimmed);\n\n  return params;\n}\n\n/**\n * Extract the parameter list and return type from a signature string.\n *\n * Input:  `(a: string, b: number): boolean`\n * Output: { params: ['a: string', 'b: number'], returnType: 'boolean' }\n */\nfunction parseSignature(sig: string): {\n  params: string[];\n  returnType: string | null;\n} {\n  const trimmed = normalize(sig);\n\n  // Find the matching closing paren for the opening paren\n  if (!trimmed.startsWith('(')) {\n    return { params: [], returnType: null };\n  }\n\n  let depth = 0;\n  let closeIndex = -1;\n\n  for (let i = 0; i < trimmed.length; i++) {\n    const ch = trimmed[i];\n    if (ch === '(') depth++;\n    else if (ch === ')') {\n      depth--;\n      if (depth === 0) {\n        closeIndex = i;\n        break;\n      }\n    }\n  }\n\n  if (closeIndex === -1) {\n    // Malformed signature — treat entire string as params\n    return { params: splitParameters(trimmed.slice(1)), returnType: null };\n  }\n\n  const paramStr = trimmed.slice(1, closeIndex);\n  const params = paramStr.length > 0 ? splitParameters(paramStr) : [];\n\n  // Everything after `)` should be `: ReturnType`\n  const rest = trimmed.slice(closeIndex + 1).trim();\n  let returnType: string | null = null;\n\n  if (rest.startsWith(':')) {\n    returnType = normalize(rest.slice(1));\n  }\n\n  return { params, returnType };\n}\n\n/**\n * Extract just the type portion from a parameter declaration.\n * `name: Type` → `Type`\n * `name?: Type` → `Type`\n * `...name: Type` → `Type`\n * If there's no `:`, returns the raw parameter string.\n */\nfunction extractParamType(param: string): string {\n  // Handle rest parameters\n  const cleaned = param.replace(/^\\.\\.\\./, '').trim();\n\n  // Find the colon that separates name from type (not inside angle brackets etc.)\n  let depth = 0;\n  for (let i = 0; i < cleaned.length; i++) {\n    const ch = cleaned[i];\n    if (ch === '<' || ch === '(' || ch === '[' || ch === '{') depth++;\n    else if (ch === '>' || ch === ')' || ch === ']' || ch === '}') depth--;\n    else if (ch === ':' && depth === 0) {\n      return normalize(cleaned.slice(i + 1));\n    }\n  }\n\n  return normalize(cleaned);\n}\n\nexport interface SignatureDiffResult {\n  changed: boolean;\n  details: string;\n}\n\n/**\n * Compare two function/method signatures and produce a human-readable\n * description of what changed.\n *\n * @param baseSig - The signature from the base (old) version, e.g. `(a: string): void`\n * @param headSig - The signature from the head (new) version\n * @returns An object with `changed` (boolean) and `details` (string describing the change)\n */\nexport function diffSignatures(\n  baseSig: string | undefined,\n  headSig: string | undefined,\n): SignatureDiffResult {\n  // Both undefined → no signature to compare\n  if (baseSig === undefined && headSig === undefined) {\n    return { changed: false, details: 'no signatures to compare' };\n  }\n\n  // One exists, other doesn't\n  if (baseSig === undefined) {\n    return { changed: true, details: 'signature added' };\n  }\n  if (headSig === undefined) {\n    return { changed: true, details: 'signature removed' };\n  }\n\n  // Quick equality check after normalization\n  const normalizedBase = normalize(baseSig);\n  const normalizedHead = normalize(headSig);\n\n  if (normalizedBase === normalizedHead) {\n    return { changed: false, details: 'signatures are identical' };\n  }\n\n  // Parse both signatures for structural comparison\n  const baseParsed = parseSignature(normalizedBase);\n  const headParsed = parseSignature(normalizedHead);\n\n  const differences: string[] = [];\n\n  // Compare parameter counts\n  const baseCount = baseParsed.params.length;\n  const headCount = headParsed.params.length;\n\n  if (baseCount !== headCount) {\n    differences.push(\n      `parameter count changed from ${baseCount} to ${headCount}`,\n    );\n  }\n\n  // Compare individual parameter types (up to the smaller count)\n  const minCount = Math.min(baseCount, headCount);\n  for (let i = 0; i < minCount; i++) {\n    const baseType = extractParamType(baseParsed.params[i]);\n    const headType = extractParamType(headParsed.params[i]);\n\n    if (baseType !== headType) {\n      const baseName = baseParsed.params[i].split(':')[0].replace(/[?.]/g, '').trim();\n      differences.push(\n        `parameter '${baseName}' type changed from '${baseType}' to '${headType}'`,\n      );\n    }\n  }\n\n  // Compare return types\n  const baseReturn = baseParsed.returnType;\n  const headReturn = headParsed.returnType;\n\n  if (baseReturn !== headReturn) {\n    if (baseReturn === null) {\n      differences.push(`return type added: '${headReturn}'`);\n    } else if (headReturn === null) {\n      differences.push(`return type removed (was '${baseReturn}')`);\n    } else {\n      differences.push(\n        `return type changed from '${baseReturn}' to '${headReturn}'`,\n      );\n    }\n  }\n\n  if (differences.length === 0) {\n    // The normalized strings differ but our structural comparison didn't catch it;\n    // report a generic change.\n    return { changed: true, details: 'signature changed' };\n  }\n\n  return { changed: true, details: differences.join('; ') };\n}\n","import fg from 'fast-glob';\nimport { posix as path } from 'node:path';\n\n/**\n * Maps a source file to its expected test file paths using common naming\n * conventions, then returns only those that actually exist on disk.\n *\n * Conventions checked (given e.g. `src/utils/parser.ts`):\n *   1. Same directory:        src/utils/parser.test.ts, src/utils/parser.spec.ts\n *   2. __tests__ sibling dir: src/utils/__tests__/parser.ts, src/utils/__tests__/parser.test.ts\n *   3. Top-level test dirs:   test/utils/parser.ts, tests/utils/parser.test.ts\n *   4. All of the above with .js/.jsx/.tsx variants as well.\n */\nexport async function mapTestFiles(\n  repoPath: string,\n  sourceFile: string,\n): Promise<string[]> {\n  const candidates = buildCandidatePaths(sourceFile);\n\n  if (candidates.length === 0) {\n    return [];\n  }\n\n  // fast-glob expects forward-slash patterns and a cwd\n  const existing = await fg(candidates, {\n    cwd: repoPath,\n    dot: false,\n    onlyFiles: true,\n  });\n\n  return existing;\n}\n\n// ---------------------------------------------------------------------------\n// Internal helpers\n// ---------------------------------------------------------------------------\n\n/** Extensions we consider valid for test files. */\nconst TEST_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'] as const;\n\n/**\n * Build all candidate test file paths for a given source file.\n * Paths are returned as repo-relative with forward slashes.\n */\nfunction buildCandidatePaths(sourceFile: string): string[] {\n  const normalized = sourceFile.replace(/\\\\/g, '/');\n  const dir = path.dirname(normalized);\n  const ext = path.extname(normalized);\n  const base = path.basename(normalized, ext);\n\n  // Derive the relative part after the first conventional source directory\n  // (e.g. `src/`). This is used for top-level test directories.\n  const subPath = stripLeadingSourceDir(normalized);\n  const subDir = path.dirname(subPath);\n  const candidates: string[] = [];\n\n  for (const testExt of TEST_EXTENSIONS) {\n    // --- 1. Same directory with .test / .spec suffix ----------------------\n    candidates.push(path.join(dir, `${base}.test${testExt}`));\n    candidates.push(path.join(dir, `${base}.spec${testExt}`));\n\n    // --- 2. __tests__ sibling directory -----------------------------------\n    const testsDir = path.join(dir, '__tests__');\n    candidates.push(path.join(testsDir, `${base}${testExt}`));\n    candidates.push(path.join(testsDir, `${base}.test${testExt}`));\n    candidates.push(path.join(testsDir, `${base}.spec${testExt}`));\n\n    // --- 3. Top-level test / tests directories ----------------------------\n    for (const topDir of ['test', 'tests']) {\n      candidates.push(path.join(topDir, subDir, `${base}${testExt}`));\n      candidates.push(path.join(topDir, subDir, `${base}.test${testExt}`));\n      candidates.push(path.join(topDir, subDir, `${base}.spec${testExt}`));\n    }\n  }\n\n  // Deduplicate (some paths may overlap when dir === '.')\n  return [...new Set(candidates)];\n}\n\n/**\n * Strips a leading conventional source directory prefix such as `src/` so that\n * we can reconstruct paths relative to a top-level `test/` directory.\n *\n * Examples:\n *   `src/utils/parser.ts`  -> `utils/parser.ts`\n *   `lib/core/index.ts`    -> `core/index.ts`\n *   `packages/foo/src/a.ts` -> `a.ts`         (strips up to and including src/)\n *   `utils/parser.ts`      -> `utils/parser.ts` (no prefix to strip)\n */\nfunction stripLeadingSourceDir(filePath: string): string {\n  // Look for the last occurrence of a conventional source dir segment.\n  const srcIndex = filePath.lastIndexOf('src/');\n  if (srcIndex !== -1) {\n    return filePath.slice(srcIndex + 'src/'.length);\n  }\n\n  const libIndex = filePath.lastIndexOf('lib/');\n  if (libIndex !== -1) {\n    return filePath.slice(libIndex + 'lib/'.length);\n  }\n\n  return filePath;\n}\n","import { ChangedFile, TestCoverageReport, TestCoverageGap } from '../types.js';\nimport { mapTestFiles } from './test-mapper.js';\n\n/**\n * Checks whether changed source files have corresponding test changes in the\n * same PR.  Returns a report with a coverage ratio and a list of \"gaps\" --\n * source files whose tests were not updated.\n */\nexport async function checkTestCoverage(\n  repoPath: string,\n  changedFiles: ChangedFile[],\n): Promise<TestCoverageReport> {\n  const sourceFiles = changedFiles.filter((f) => f.category === 'source');\n  const changedTestPaths = new Set(\n    changedFiles.filter((f) => f.category === 'test').map((f) => f.path),\n  );\n\n  if (sourceFiles.length === 0) {\n    return {\n      changedSourceFiles: 0,\n      sourceFilesWithTestChanges: 0,\n      coverageRatio: 1,\n      gaps: [],\n    };\n  }\n\n  const gaps: TestCoverageGap[] = [];\n  let sourceFilesWithTestChanges = 0;\n\n  for (const source of sourceFiles) {\n    const expectedTestFiles = await mapTestFiles(repoPath, source.path);\n    const testFileExists = expectedTestFiles.length > 0;\n    const testFileChanged = expectedTestFiles.some((t) =>\n      changedTestPaths.has(t),\n    );\n\n    if (testFileChanged) {\n      sourceFilesWithTestChanges++;\n    } else {\n      gaps.push({\n        sourceFile: source.path,\n        expectedTestFiles,\n        testFileExists,\n        testFileChanged: false,\n      });\n    }\n  }\n\n  const coverageRatio =\n    sourceFiles.length > 0\n      ? sourceFilesWithTestChanges / sourceFiles.length\n      : 0;\n\n  return {\n    changedSourceFiles: sourceFiles.length,\n    sourceFilesWithTestChanges,\n    coverageRatio,\n    gaps,\n  };\n}\n","import simpleGit from 'simple-git';\nimport fg from 'fast-glob';\nimport { readFile } from 'node:fs/promises';\nimport { join as joinPath } from 'node:path';\nimport { ChangedFile, DocStalenessReport, StaleReference } from '../types.js';\n\n/**\n * Checks whether documentation files in the repository reference symbols or\n * file paths that were deleted, removed, or renamed in the current change set.\n */\nexport async function checkDocStaleness(\n  repoPath: string,\n  changedFiles: ChangedFile[],\n  baseBranch: string,\n  headBranch: string,\n): Promise<DocStalenessReport> {\n  const git = simpleGit(repoPath);\n\n  // ---- 1. Discover all doc files in the repo at HEAD ---------------------\n  const docPatterns = ['**/*.md', '**/*.mdx'];\n  const docFiles = await fg(docPatterns, {\n    cwd: repoPath,\n    ignore: ['**/node_modules/**'],\n    dot: false,\n    onlyFiles: true,\n  });\n\n  if (docFiles.length === 0) {\n    return { staleReferences: [], checkedFiles: [] };\n  }\n\n  // ---- 2. Collect references we want to search for ----------------------\n  const deletedPaths = buildDeletedPaths(changedFiles);\n  const renamedPaths = buildRenamedPaths(changedFiles);\n  const removedSymbols = await collectRemovedSymbols(\n    git,\n    changedFiles,\n    baseBranch,\n    headBranch,\n  );\n\n  // If there is nothing to look for, short-circuit.\n  if (\n    deletedPaths.length === 0 &&\n    renamedPaths.length === 0 &&\n    removedSymbols.length === 0\n  ) {\n    return { staleReferences: [], checkedFiles: docFiles };\n  }\n\n  // ---- 3. Pre-compile symbol regexes for efficient scanning ----------------\n  const symbolPatterns = removedSymbols.map((sym) => ({\n    ...sym,\n    regex: new RegExp(`\\\\b${escapeRegex(sym.name)}\\\\b`),\n  }));\n\n  // ---- 4. Scan doc files for stale references ---------------------------\n  const staleReferences: StaleReference[] = [];\n\n  for (const docFile of docFiles) {\n    const content = await safeReadFile(repoPath, docFile, git, headBranch);\n    if (content === null) {\n      continue;\n    }\n\n    const lines = content.split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const lineNumber = i + 1;\n\n      // Check deleted file paths\n      for (const dp of deletedPaths) {\n        if (line.includes(dp)) {\n          staleReferences.push({\n            docFile,\n            line: lineNumber,\n            reference: dp,\n            reason: 'referenced file was deleted',\n          });\n        }\n      }\n\n      // Check renamed file paths (old path)\n      for (const rp of renamedPaths) {\n        if (line.includes(rp.oldPath)) {\n          staleReferences.push({\n            docFile,\n            line: lineNumber,\n            reference: rp.oldPath,\n            reason: `referenced file was renamed to ${rp.newPath}`,\n          });\n        }\n      }\n\n      // Check removed symbols (word-boundary match, pre-compiled)\n      for (const sym of symbolPatterns) {\n        if (sym.regex.test(line)) {\n          staleReferences.push({\n            docFile,\n            line: lineNumber,\n            reference: sym.name,\n            reason: `referenced symbol was removed from ${sym.sourceFile}`,\n          });\n        }\n      }\n    }\n  }\n\n  return { staleReferences, checkedFiles: docFiles };\n}\n\n// ---------------------------------------------------------------------------\n// Internal helpers\n// ---------------------------------------------------------------------------\n\ninterface RemovedSymbol {\n  name: string;\n  sourceFile: string;\n}\n\ninterface RenamedPath {\n  oldPath: string;\n  newPath: string;\n}\n\n/** Collect file paths that were deleted. */\nfunction buildDeletedPaths(changedFiles: ChangedFile[]): string[] {\n  return changedFiles\n    .filter((f) => f.status === 'deleted')\n    .map((f) => f.path);\n}\n\n/** Collect old paths from renames. */\nfunction buildRenamedPaths(changedFiles: ChangedFile[]): RenamedPath[] {\n  return changedFiles\n    .filter((f) => f.status === 'renamed' && f.oldPath)\n    .map((f) => ({ oldPath: f.oldPath!, newPath: f.path }));\n}\n\n/**\n * For deleted source files, derive the filename stem as a potential reference.\n * For modified source files, diff the exported symbols between base and head\n * to find removed exports.\n */\nasync function collectRemovedSymbols(\n  git: ReturnType<typeof simpleGit>,\n  changedFiles: ChangedFile[],\n  baseBranch: string,\n  headBranch: string,\n): Promise<RemovedSymbol[]> {\n  const removed: RemovedSymbol[] = [];\n\n  for (const file of changedFiles) {\n    if (file.category !== 'source') {\n      continue;\n    }\n\n    if (file.status === 'deleted') {\n      // Use the filename stem as a symbol reference\n      const stem = filenameStem(file.path);\n      if (stem && !isGenericName(stem)) {\n        removed.push({ name: stem, sourceFile: file.path });\n      }\n\n      // Also extract exported symbols from the base version\n      const baseContent = await safeShowFile(git, baseBranch, file.path);\n      if (baseContent) {\n        for (const sym of extractExportedSymbolNames(baseContent)) {\n          removed.push({ name: sym, sourceFile: file.path });\n        }\n      }\n    } else if (file.status === 'modified') {\n      const baseContent = await safeShowFile(git, baseBranch, file.path);\n      const headContent = await safeShowFile(git, headBranch, file.path);\n\n      if (baseContent) {\n        const baseSymbols = extractExportedSymbolNames(baseContent);\n        const headSymbols = new Set(\n          headContent ? extractExportedSymbolNames(headContent) : [],\n        );\n\n        for (const sym of baseSymbols) {\n          if (!headSymbols.has(sym)) {\n            removed.push({ name: sym, sourceFile: file.path });\n          }\n        }\n      }\n    }\n  }\n\n  return removed;\n}\n\n/**\n * Regex-based extraction of exported symbol names from TypeScript/JavaScript\n * source code.  Matches patterns like:\n *   export function foo(\n *   export async function bar(\n *   export class Baz\n *   export const qux\n *   export let quux\n *   export var quuz\n *   export type Foo\n *   export interface Bar\n *   export enum Status\n *   export default function foo(\n *   export default class Bar\n */\nconst EXPORT_REGEX =\n  /export\\s+(?:default\\s+)?(?:async\\s+)?(?:function\\s*\\*?\\s*|class\\s+|const\\s+|let\\s+|var\\s+|type\\s+|interface\\s+|enum\\s+)([A-Za-z_$][A-Za-z0-9_$]*)/g;\n\nfunction extractExportedSymbolNames(content: string): string[] {\n  const names: string[] = [];\n  let match: RegExpExecArray | null;\n\n  const regex = new RegExp(EXPORT_REGEX.source, EXPORT_REGEX.flags);\n\n  while ((match = regex.exec(content)) !== null) {\n    const name = match[1];\n    if (name) {\n      names.push(name);\n    }\n  }\n\n  return [...new Set(names)];\n}\n\n/** Get the filename without extension. */\nfunction filenameStem(filePath: string): string {\n  const name = filePath.replace(/\\\\/g, '/').split('/').pop() ?? '';\n  const dotIndex = name.indexOf('.');\n  return dotIndex === -1 ? name : name.slice(0, dotIndex);\n}\n\n/** Filter out overly generic file stems that would cause false positives. */\nfunction isGenericName(name: string): boolean {\n  const GENERIC = new Set([\n    'index',\n    'main',\n    'app',\n    'mod',\n    'lib',\n    'utils',\n    'helpers',\n    'types',\n    'constants',\n    'config',\n  ]);\n  return GENERIC.has(name.toLowerCase());\n}\n\n/** Safely read a file from a git branch, returning null on failure. */\nasync function safeShowFile(\n  git: ReturnType<typeof simpleGit>,\n  branch: string,\n  filePath: string,\n): Promise<string | null> {\n  try {\n    return await git.show(`${branch}:${filePath}`);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Read a doc file -- first try the working tree (fs), fall back to git show\n * at headBranch if the file is not on disk (e.g. running in a detached state).\n */\nasync function safeReadFile(\n  repoPath: string,\n  relPath: string,\n  git: ReturnType<typeof simpleGit>,\n  headBranch: string,\n): Promise<string | null> {\n  try {\n    return await readFile(joinPath(repoPath, relPath), 'utf-8');\n  } catch {\n    // File might not be on disk if we're on a different branch; try git show\n    return safeShowFile(git, headBranch, relPath);\n  }\n}\n\n/** Escape special regex characters in a string. */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import fg from 'fast-glob';\nimport { readFile } from 'fs/promises';\nimport { resolve, relative, dirname } from 'path';\nimport { ChangedFile, ImpactGraph, ImpactEdge } from '../types.js';\n\n/**\n * Regex patterns for extracting import paths from TypeScript/JavaScript files.\n */\nconst STATIC_IMPORT_RE = /(?:import|export)\\s+(?:[\\s\\S]*?\\s+from\\s+)?['\"]([^'\"]+)['\"]/g;\nconst DYNAMIC_IMPORT_RE = /import\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g;\nconst REQUIRE_RE = /require\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g;\n\nconst RESOLVE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'];\nconst INDEX_FILES = ['index.ts', 'index.tsx', 'index.js', 'index.jsx'];\n\n/**\n * Extract all import paths from a file's content.\n */\nfunction extractImportPaths(content: string): string[] {\n  const paths: string[] = [];\n\n  for (const re of [STATIC_IMPORT_RE, DYNAMIC_IMPORT_RE, REQUIRE_RE]) {\n    const pattern = new RegExp(re.source, re.flags);\n    let match: RegExpExecArray | null;\n    while ((match = pattern.exec(content)) !== null) {\n      paths.push(match[1]);\n    }\n  }\n\n  return paths;\n}\n\n/**\n * Check if an import path is relative (starts with . or ..).\n */\nfunction isRelativeImport(importPath: string): boolean {\n  return importPath.startsWith('./') || importPath.startsWith('../');\n}\n\n/**\n * Resolve a relative import to a repo-relative path by trying various\n * extensions and index file patterns.\n *\n * Returns the repo-relative path if a matching file exists in the file set,\n * or null if the import cannot be resolved.\n */\nfunction resolveImport(\n  importPath: string,\n  importerRepoRelPath: string,\n  allFiles: Set<string>,\n): string | null {\n  const importerDir = dirname(importerRepoRelPath);\n  const resolved = resolve('/', importerDir, importPath).slice(1); // use '/' as fake root for clean path resolution\n\n  // Normalize: remove leading slash if present\n  const normalized = resolved.startsWith('/') ? resolved.slice(1) : resolved;\n\n  // 1. Exact match (already has extension)\n  if (allFiles.has(normalized)) {\n    return normalized;\n  }\n\n  // 2. Try appending each extension\n  for (const ext of RESOLVE_EXTENSIONS) {\n    const candidate = normalized + ext;\n    if (allFiles.has(candidate)) {\n      return candidate;\n    }\n  }\n\n  // 3. Try as directory with index file\n  for (const indexFile of INDEX_FILES) {\n    const candidate = normalized + '/' + indexFile;\n    if (allFiles.has(candidate)) {\n      return candidate;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Build an impact graph showing which files are directly changed and which\n * are indirectly affected through import dependencies.\n *\n * Uses BFS over a reverse dependency map (dependents) to find files that\n * transitively depend on the changed files, up to `maxDepth` levels.\n */\nexport async function buildImpactGraph(\n  repoPath: string,\n  changedFiles: ChangedFile[],\n  maxDepth: number = 3,\n): Promise<ImpactGraph> {\n  // 1. Discover all source files in the repo\n  const absolutePaths = await fg('**/*.{ts,tsx,js,jsx}', {\n    cwd: repoPath,\n    ignore: ['**/node_modules/**', '**/dist/**', '**/.git/**'],\n    absolute: true,\n  });\n\n  // Build a set of repo-relative paths for quick lookup\n  const repoRelativePaths = absolutePaths.map((abs) => relative(repoPath, abs));\n  const allFilesSet = new Set(repoRelativePaths);\n\n  // 2. Parse imports for every source file and build a reverse dependency map\n  // reverseDeps: key = file that is imported, value = set of files that import it\n  const reverseDeps = new Map<string, Set<string>>();\n\n  // Process files in batches to avoid EMFILE (too many open files)\n  const BATCH_SIZE = 50;\n  for (let i = 0; i < repoRelativePaths.length; i += BATCH_SIZE) {\n    const batch = repoRelativePaths.slice(i, i + BATCH_SIZE);\n    await Promise.all(\n      batch.map(async (relPath) => {\n        const absPath = resolve(repoPath, relPath);\n        let content: string;\n        try {\n          content = await readFile(absPath, 'utf-8');\n        } catch {\n          return; // skip unreadable files\n        }\n\n        const importPaths = extractImportPaths(content);\n\n        for (const importPath of importPaths) {\n          if (!isRelativeImport(importPath)) {\n            continue; // skip node_modules / bare specifier imports\n          }\n\n          const resolved = resolveImport(importPath, relPath, allFilesSet);\n          if (resolved === null) {\n            continue;\n          }\n\n          let dependents = reverseDeps.get(resolved);\n          if (!dependents) {\n            dependents = new Set();\n            reverseDeps.set(resolved, dependents);\n          }\n          dependents.add(relPath);\n        }\n      }),\n    );\n  }\n\n  // 3. Identify directly changed source files\n  const directlyChanged = changedFiles\n    .filter((f) => f.category === 'source')\n    .map((f) => f.path);\n\n  const directlyChangedSet = new Set(directlyChanged);\n\n  // 4. BFS traversal over reverse dependencies to find indirectly affected files\n  const visited = new Set<string>(directlyChanged);\n  const edges: ImpactEdge[] = [];\n  let frontier = [...directlyChanged];\n\n  for (let depth = 0; depth < maxDepth && frontier.length > 0; depth++) {\n    const nextFrontier: string[] = [];\n\n    for (const file of frontier) {\n      const dependents = reverseDeps.get(file);\n      if (!dependents) {\n        continue;\n      }\n\n      for (const dependent of dependents) {\n        edges.push({\n          from: dependent,\n          to: file,\n          type: 'imports',\n        });\n\n        if (!visited.has(dependent)) {\n          visited.add(dependent);\n          nextFrontier.push(dependent);\n        }\n      }\n    }\n\n    frontier = nextFrontier;\n  }\n\n  // 5. Indirectly affected = visited files minus the directly changed ones\n  const indirectlyAffected = [...visited].filter(\n    (f) => !directlyChangedSet.has(f),\n  );\n\n  return {\n    directlyChanged,\n    indirectlyAffected,\n    edges,\n  };\n}\n","import {\n  RiskFactor,\n  ChangedFile,\n  BreakingChange,\n  TestCoverageReport,\n  DocStalenessReport,\n  ImpactGraph,\n} from '../types.js';\n\n/**\n * CI/build config file patterns that represent high-risk configuration changes.\n */\nconst CI_BUILD_CONFIG_PATTERNS = [\n  /^\\.github\\//,\n  /Dockerfile/i,\n  /docker-compose/i,\n  /webpack\\.config/,\n  /vite\\.config/,\n  /rollup\\.config/,\n  /esbuild\\.config/,\n  /turbo\\.json$/,\n  /\\.gitlab-ci/,\n  /Jenkinsfile/i,\n  /\\.circleci\\//,\n];\n\n/**\n * Evaluate the risk factor for breaking API changes.\n *\n * Weight: 0.30\n * Score: 100 if any high-severity, 60 if medium, 30 if low-only, 0 if none.\n */\nexport function evaluateBreakingChangesFactor(\n  breakingChanges: BreakingChange[],\n): RiskFactor {\n  if (breakingChanges.length === 0) {\n    return {\n      name: 'Breaking changes',\n      score: 0,\n      weight: 0.30,\n      description: 'No breaking API changes detected.',\n    };\n  }\n\n  const hasHigh = breakingChanges.some((bc) => bc.severity === 'high');\n  const hasMedium = breakingChanges.some((bc) => bc.severity === 'medium');\n\n  let score: number;\n  if (hasHigh) {\n    score = 100;\n  } else if (hasMedium) {\n    score = 60;\n  } else {\n    score = 30;\n  }\n\n  const details = breakingChanges.map(\n    (bc) => `${bc.type} of \"${bc.symbolName}\" in ${bc.filePath} (${bc.severity})`,\n  );\n\n  return {\n    name: 'Breaking changes',\n    score,\n    weight: 0.30,\n    description: `${breakingChanges.length} breaking change(s) detected.`,\n    details,\n  };\n}\n\n/**\n * Evaluate the risk factor for untested source changes.\n *\n * Weight: 0.25\n * Score: (1 - coverageRatio) * 100\n */\nexport function evaluateUntestedChangesFactor(\n  coverage: TestCoverageReport,\n): RiskFactor {\n  const score = coverage.changedSourceFiles === 0\n    ? 0\n    : (1 - coverage.coverageRatio) * 100;\n\n  const details: string[] = [];\n  if (coverage.gaps.length > 0) {\n    for (const gap of coverage.gaps) {\n      const testStatus = gap.testFileExists\n        ? 'test exists but not updated'\n        : 'no test file found';\n      details.push(`${gap.sourceFile}: ${testStatus}`);\n    }\n  }\n\n  const description =\n    coverage.changedSourceFiles === 0\n      ? 'No source files changed.'\n      : `${coverage.sourceFilesWithTestChanges}/${coverage.changedSourceFiles} changed source files have corresponding test changes.`;\n\n  return {\n    name: 'Untested changes',\n    score,\n    weight: 0.25,\n    description,\n    ...(details.length > 0 ? { details } : {}),\n  };\n}\n\n/**\n * Evaluate the risk factor based on the overall diff size.\n *\n * Weight: 0.15\n * Score: 0 if <100 lines, 50 if 100-500, 80 if 500-1000, 100 if >1000\n */\nexport function evaluateDiffSizeFactor(changedFiles: ChangedFile[]): RiskFactor {\n  const totalLines = changedFiles.reduce(\n    (sum, f) => sum + f.additions + f.deletions,\n    0,\n  );\n\n  let score: number;\n  if (totalLines > 1000) {\n    score = 100;\n  } else if (totalLines >= 500) {\n    score = 80;\n  } else if (totalLines >= 100) {\n    score = 50;\n  } else {\n    score = 0;\n  }\n\n  return {\n    name: 'Diff size',\n    score,\n    weight: 0.15,\n    description: `${totalLines} total lines changed across ${changedFiles.length} file(s).`,\n  };\n}\n\n/**\n * Evaluate the risk factor for stale documentation references.\n *\n * Weight: 0.10\n * Score: min(staleReferences.length * 20, 100)\n */\nexport function evaluateDocStalenessFactor(\n  staleness: DocStalenessReport,\n): RiskFactor {\n  const score = Math.min(staleness.staleReferences.length * 20, 100);\n\n  const details =\n    staleness.staleReferences.length > 0\n      ? staleness.staleReferences.map(\n          (ref) => `${ref.docFile}:${ref.line} - \"${ref.reference}\" (${ref.reason})`,\n        )\n      : undefined;\n\n  const description =\n    staleness.staleReferences.length === 0\n      ? 'No stale documentation references found.'\n      : `${staleness.staleReferences.length} stale documentation reference(s) found.`;\n\n  return {\n    name: 'Stale documentation',\n    score,\n    weight: 0.10,\n    description,\n    ...(details ? { details } : {}),\n  };\n}\n\n/**\n * Evaluate the risk factor for configuration file changes.\n *\n * Weight: 0.10\n * Score: 100 if CI/build config changed, 50 if other config, 0 if none.\n */\nexport function evaluateConfigChangesFactor(\n  changedFiles: ChangedFile[],\n): RiskFactor {\n  const configFiles = changedFiles.filter((f) => f.category === 'config');\n\n  if (configFiles.length === 0) {\n    return {\n      name: 'Config file changes',\n      score: 0,\n      weight: 0.10,\n      description: 'No configuration files changed.',\n    };\n  }\n\n  const hasCiBuildConfig = configFiles.some((f) =>\n    CI_BUILD_CONFIG_PATTERNS.some((pattern) => pattern.test(f.path)),\n  );\n\n  const score = hasCiBuildConfig ? 100 : 50;\n\n  const details = configFiles.map((f) => f.path);\n\n  const description = hasCiBuildConfig\n    ? `CI/build configuration changed (${configFiles.length} config file(s)).`\n    : `${configFiles.length} configuration file(s) changed.`;\n\n  return {\n    name: 'Config file changes',\n    score,\n    weight: 0.10,\n    description,\n    details,\n  };\n}\n\n/**\n * Evaluate the risk factor based on how many files are indirectly affected\n * through the import dependency graph.\n *\n * Weight: 0.10\n * Score: min(indirectlyAffected.length * 10, 100)\n */\nexport function evaluateImpactBreadthFactor(\n  impact: ImpactGraph,\n): RiskFactor {\n  const count = impact.indirectlyAffected.length;\n  const score = Math.min(count * 10, 100);\n\n  const description =\n    count === 0\n      ? 'No indirectly affected files detected.'\n      : `${count} file(s) indirectly affected through import dependencies.`;\n\n  const details =\n    count > 0 ? impact.indirectlyAffected.slice(0, 20) : undefined;\n\n  return {\n    name: 'Impact breadth',\n    score,\n    weight: 0.10,\n    description,\n    ...(details ? { details } : {}),\n  };\n}\n","import {\n  RiskAssessment,\n  ChangedFile,\n  BreakingChange,\n  TestCoverageReport,\n  DocStalenessReport,\n  ImpactGraph,\n} from '../types.js';\nimport {\n  evaluateBreakingChangesFactor,\n  evaluateUntestedChangesFactor,\n  evaluateDiffSizeFactor,\n  evaluateDocStalenessFactor,\n  evaluateConfigChangesFactor,\n  evaluateImpactBreadthFactor,\n} from './factors.js';\n\n/**\n * Determine the risk level label from a numeric score.\n *\n *   0-25  -> low\n *  26-50  -> medium\n *  51-75  -> high\n *  76+    -> critical\n */\nfunction scoreToLevel(score: number): RiskAssessment['level'] {\n  if (score <= 25) return 'low';\n  if (score <= 50) return 'medium';\n  if (score <= 75) return 'high';\n  return 'critical';\n}\n\n/**\n * Calculate a weighted risk assessment from all individual risk factors.\n *\n * Formula: total_score = sum(factor_score * factor_weight) / sum(factor_weight)\n *\n * The final score is rounded to the nearest integer.\n */\nexport function calculateRisk(\n  changedFiles: ChangedFile[],\n  breakingChanges: BreakingChange[],\n  testCoverage: TestCoverageReport,\n  docStaleness: DocStalenessReport,\n  impactGraph: ImpactGraph,\n): RiskAssessment {\n  const factors = [\n    evaluateBreakingChangesFactor(breakingChanges),\n    evaluateUntestedChangesFactor(testCoverage),\n    evaluateDiffSizeFactor(changedFiles),\n    evaluateDocStalenessFactor(docStaleness),\n    evaluateConfigChangesFactor(changedFiles),\n    evaluateImpactBreadthFactor(impactGraph),\n  ];\n\n  const weightedSum = factors.reduce(\n    (sum, factor) => sum + factor.score * factor.weight,\n    0,\n  );\n\n  const totalWeight = factors.reduce(\n    (sum, factor) => sum + factor.weight,\n    0,\n  );\n\n  const score = Math.round(weightedSum / totalWeight);\n  const level = scoreToLevel(score);\n\n  return {\n    score,\n    level,\n    factors,\n  };\n}\n","import { PRAnalysis } from '../types.js';\n\n/**\n * Format a PRAnalysis result as a readable Markdown report suitable for\n * posting as a PR comment or writing to a file.\n */\nexport function formatMarkdown(analysis: PRAnalysis): string {\n  const sections: string[] = [];\n\n  // ── Header ──────────────────────────────────────────────────────────────────\n  sections.push('# PR Impact Analysis');\n  sections.push('');\n  sections.push(`**Repository:** ${analysis.repoPath}`);\n  sections.push(`**Comparing:** \\`${analysis.baseBranch}\\` ← \\`${analysis.headBranch}\\``);\n\n  // ── Risk Score ──────────────────────────────────────────────────────────────\n  sections.push('');\n  sections.push(`## Risk Score: ${analysis.riskScore.score}/100 (${analysis.riskScore.level})`);\n  sections.push('');\n\n  if (analysis.riskScore.factors.length > 0) {\n    sections.push('| Factor | Score | Weight |');\n    sections.push('|--------|------:|-------:|');\n\n    for (const factor of analysis.riskScore.factors) {\n      sections.push(`| ${factor.name} | ${factor.score} | ${factor.weight} |`);\n    }\n  } else {\n    sections.push('No risk factors identified.');\n  }\n\n  // ── Summary ─────────────────────────────────────────────────────────────────\n  sections.push('');\n  sections.push('## Summary');\n  sections.push('');\n  sections.push(analysis.summary);\n\n  // ── Changed Files ───────────────────────────────────────────────────────────\n  sections.push('');\n  sections.push(`## Changed Files (${analysis.changedFiles.length})`);\n  sections.push('');\n\n  if (analysis.changedFiles.length > 0) {\n    sections.push('| File | Status | +/- | Category |');\n    sections.push('|------|--------|-----|----------|');\n\n    for (const file of analysis.changedFiles) {\n      const change = `+${file.additions}/-${file.deletions}`;\n      sections.push(`| ${file.path} | ${file.status} | ${change} | ${file.category} |`);\n    }\n  } else {\n    sections.push('No files changed.');\n  }\n\n  // ── Breaking Changes ────────────────────────────────────────────────────────\n  sections.push('');\n  sections.push(`## Breaking Changes (${analysis.breakingChanges.length})`);\n  sections.push('');\n\n  if (analysis.breakingChanges.length > 0) {\n    sections.push('| Symbol | Type | Severity | File |');\n    sections.push('|--------|------|----------|------|');\n\n    for (const bc of analysis.breakingChanges) {\n      const typeLabel = formatBreakingChangeType(bc.type);\n      sections.push(`| ${bc.symbolName} | ${typeLabel} | ${bc.severity} | ${bc.filePath} |`);\n    }\n  } else {\n    sections.push('No breaking changes detected.');\n  }\n\n  // ── Test Coverage ───────────────────────────────────────────────────────────\n  sections.push('');\n  sections.push('## Test Coverage');\n  sections.push('');\n\n  const coveragePercent = Math.round(analysis.testCoverage.coverageRatio * 100);\n  sections.push(`- **Changed source files:** ${analysis.testCoverage.changedSourceFiles}`);\n  sections.push(`- **Files with test changes:** ${analysis.testCoverage.sourceFilesWithTestChanges}`);\n  sections.push(`- **Coverage ratio:** ${coveragePercent}%`);\n\n  if (analysis.testCoverage.gaps.length > 0) {\n    sections.push('');\n    sections.push('### Gaps');\n    sections.push('');\n\n    for (const gap of analysis.testCoverage.gaps) {\n      const testStatus = gap.testFileExists\n        ? 'test file exists but was not changed'\n        : 'no test file found';\n      sections.push(`- **${gap.sourceFile}** — ${testStatus}`);\n\n      if (gap.expectedTestFiles.length > 0) {\n        for (const tf of gap.expectedTestFiles) {\n          sections.push(`  - ${tf}`);\n        }\n      }\n    }\n  }\n\n  // ── Documentation Staleness ─────────────────────────────────────────────────\n  sections.push('');\n  sections.push('## Documentation Staleness');\n  sections.push('');\n\n  if (analysis.docStaleness.staleReferences.length > 0) {\n    for (const ref of analysis.docStaleness.staleReferences) {\n      sections.push(`- **${ref.docFile}** (line ${ref.line}): \\`${ref.reference}\\` — ${ref.reason}`);\n    }\n  } else {\n    sections.push('No stale references found.');\n  }\n\n  // ── Impact Graph ────────────────────────────────────────────────────────────\n  sections.push('');\n  sections.push('## Impact Graph');\n  sections.push('');\n  sections.push(`- **Directly changed:** ${analysis.impactGraph.directlyChanged.length} file${analysis.impactGraph.directlyChanged.length === 1 ? '' : 's'}`);\n  sections.push(`- **Indirectly affected:** ${analysis.impactGraph.indirectlyAffected.length} file${analysis.impactGraph.indirectlyAffected.length === 1 ? '' : 's'}`);\n\n  if (analysis.impactGraph.edges.length > 0) {\n    sections.push('');\n    sections.push('### Dependency Edges');\n    sections.push('');\n\n    for (const edge of analysis.impactGraph.edges) {\n      sections.push(`- ${edge.from} → ${edge.to} (\\`${edge.type}\\`)`);\n    }\n  }\n\n  // Final newline\n  sections.push('');\n\n  return sections.join('\\n');\n}\n\n/**\n * Convert a breaking change type enum value into a human-readable label.\n */\nfunction formatBreakingChangeType(\n  type: 'removed_export' | 'changed_signature' | 'changed_type' | 'renamed_export',\n): string {\n  switch (type) {\n    case 'removed_export':\n      return 'removed export';\n    case 'changed_signature':\n      return 'changed signature';\n    case 'changed_type':\n      return 'changed type';\n    case 'renamed_export':\n      return 'renamed export';\n  }\n}\n","import { PRAnalysis } from '../types.js';\n\n/**\n * Format a PRAnalysis result as a pretty-printed JSON string.\n */\nexport function formatJSON(analysis: PRAnalysis): string {\n  return JSON.stringify(analysis, null, 2);\n}\n"],"mappings":"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","names":["simpleGit","simpleGit","trimmed","getExtension","simpleGit","simpleGit","fg","fg","readFile","simpleGit"]}